{"ast":null,"code":"function getLocator(source, options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  var offsetLine = options.offsetLine || 0;\n  var offsetColumn = options.offsetColumn || 0;\n  var originalLines = source.split('\\n');\n  var start = 0;\n  var lineRanges = originalLines.map(function (line, i) {\n    var end = start + line.length + 1;\n    var range = {\n      start: start,\n      end: end,\n      line: i\n    };\n    start = end;\n    return range;\n  });\n  var i = 0;\n\n  function rangeContains(range, index) {\n    return range.start <= index && index < range.end;\n  }\n\n  function getLocation(range, index) {\n    return {\n      line: offsetLine + range.line,\n      column: offsetColumn + index - range.start,\n      character: index\n    };\n  }\n\n  function locate(search, startIndex) {\n    if (typeof search === 'string') {\n      search = source.indexOf(search, startIndex || 0);\n    }\n\n    var range = lineRanges[i];\n    var d = search >= range.end ? 1 : -1;\n\n    while (range) {\n      if (rangeContains(range, search)) return getLocation(range, search);\n      i += d;\n      range = lineRanges[i];\n    }\n  }\n\n  return locate;\n}\n\nfunction locate(source, search, options) {\n  if (typeof options === 'number') {\n    throw new Error('locate takes a { startIndex, offsetLine, offsetColumn } object as the third argument');\n  }\n\n  return getLocator(source, options)(search, options && options.startIndex);\n}\n\nvar validNameCharacters = /[a-zA-Z0-9:_-]/;\nvar whitespace = /[\\s\\t\\r\\n]/;\nvar quotemark = /['\"]/;\n\nfunction repeat(str, i) {\n  var result = '';\n\n  while (i--) {\n    result += str;\n  }\n\n  return result;\n}\n\nfunction parse(source) {\n  var header = '';\n  var stack = [];\n  var state = metadata;\n  var currentElement = null;\n  var root = null;\n\n  function error(message) {\n    var ref = locate(source, i);\n    var line = ref.line;\n    var column = ref.column;\n    var before = source.slice(0, i);\n    var beforeLine = /(^|\\n).*$/.exec(before)[0].replace(/\\t/g, '  ');\n    var after = source.slice(i);\n    var afterLine = /.*(\\n|$)/.exec(after)[0];\n    var snippet = \"\" + beforeLine + afterLine + \"\\n\" + repeat(' ', beforeLine.length) + \"^\";\n    throw new Error(message + \" (\" + line + \":\" + column + \"). If this is valid SVG, it's probably a bug in svg-parser. Please raise an issue at https://github.com/Rich-Harris/svg-parser/issues – thanks!\\n\\n\" + snippet);\n  }\n\n  function metadata() {\n    while (i < source.length && source[i] !== '<' || !validNameCharacters.test(source[i + 1])) {\n      header += source[i++];\n    }\n\n    return neutral();\n  }\n\n  function neutral() {\n    var text = '';\n\n    while (i < source.length && source[i] !== '<') {\n      text += source[i++];\n    }\n\n    if (/\\S/.test(text)) {\n      currentElement.children.push({\n        type: 'text',\n        value: text\n      });\n    }\n\n    if (source[i] === '<') {\n      return tag;\n    }\n\n    return neutral;\n  }\n\n  function tag() {\n    var char = source[i];\n\n    if (char === '?') {\n      return neutral;\n    } // <?xml...\n\n\n    if (char === '!') {\n      if (source.slice(i + 1, i + 3) === '--') {\n        return comment;\n      }\n\n      if (source.slice(i + 1, i + 8) === '[CDATA[') {\n        return cdata;\n      }\n\n      if (/doctype/i.test(source.slice(i + 1, i + 8))) {\n        return neutral;\n      }\n    }\n\n    if (char === '/') {\n      return closingTag;\n    }\n\n    var tagName = getName();\n    var element = {\n      type: 'element',\n      tagName: tagName,\n      properties: {},\n      children: []\n    };\n\n    if (currentElement) {\n      currentElement.children.push(element);\n    } else {\n      root = element;\n    }\n\n    var attribute;\n\n    while (i < source.length && (attribute = getAttribute())) {\n      element.properties[attribute.name] = attribute.value;\n    }\n\n    var selfClosing = false;\n\n    if (source[i] === '/') {\n      i += 1;\n      selfClosing = true;\n    }\n\n    if (source[i] !== '>') {\n      error('Expected >');\n    }\n\n    if (!selfClosing) {\n      currentElement = element;\n      stack.push(element);\n    }\n\n    return neutral;\n  }\n\n  function comment() {\n    var index = source.indexOf('-->', i);\n\n    if (!~index) {\n      error('expected -->');\n    }\n\n    i = index + 2;\n    return neutral;\n  }\n\n  function cdata() {\n    var index = source.indexOf(']]>', i);\n\n    if (!~index) {\n      error('expected ]]>');\n    }\n\n    currentElement.children.push(source.slice(i + 7, index));\n    i = index + 2;\n    return neutral;\n  }\n\n  function closingTag() {\n    var tagName = getName();\n\n    if (!tagName) {\n      error('Expected tag name');\n    }\n\n    if (tagName !== currentElement.tagName) {\n      error(\"Expected closing tag </\" + tagName + \"> to match opening tag <\" + currentElement.tagName + \">\");\n    }\n\n    allowSpaces();\n\n    if (source[i] !== '>') {\n      error('Expected >');\n    }\n\n    stack.pop();\n    currentElement = stack[stack.length - 1];\n    return neutral;\n  }\n\n  function getName() {\n    var name = '';\n\n    while (i < source.length && validNameCharacters.test(source[i])) {\n      name += source[i++];\n    }\n\n    return name;\n  }\n\n  function getAttribute() {\n    if (!whitespace.test(source[i])) {\n      return null;\n    }\n\n    allowSpaces();\n    var name = getName();\n\n    if (!name) {\n      return null;\n    }\n\n    var value = true;\n    allowSpaces();\n\n    if (source[i] === '=') {\n      i += 1;\n      allowSpaces();\n      value = getAttributeValue();\n\n      if (!isNaN(value) && value.trim() !== '') {\n        value = +value;\n      } // TODO whitelist numeric attributes?\n\n    }\n\n    return {\n      name: name,\n      value: value\n    };\n  }\n\n  function getAttributeValue() {\n    return quotemark.test(source[i]) ? getQuotedAttributeValue() : getUnquotedAttributeValue();\n  }\n\n  function getUnquotedAttributeValue() {\n    var value = '';\n\n    do {\n      var char = source[i];\n\n      if (char === ' ' || char === '>' || char === '/') {\n        return value;\n      }\n\n      value += char;\n      i += 1;\n    } while (i < source.length);\n\n    return value;\n  }\n\n  function getQuotedAttributeValue() {\n    var quotemark = source[i++];\n    var value = '';\n    var escaped = false;\n\n    while (i < source.length) {\n      var char = source[i++];\n\n      if (char === quotemark && !escaped) {\n        return value;\n      }\n\n      if (char === '\\\\' && !escaped) {\n        escaped = true;\n      }\n\n      value += escaped ? \"\\\\\" + char : char;\n      escaped = false;\n    }\n  }\n\n  function allowSpaces() {\n    while (i < source.length && whitespace.test(source[i])) {\n      i += 1;\n    }\n  }\n\n  var i = metadata.length;\n\n  while (i < source.length) {\n    if (!state) {\n      error('Unexpected character');\n    }\n\n    state = state();\n    i += 1;\n  }\n\n  if (state !== neutral) {\n    error('Unexpected end of input');\n  }\n\n  if (root.tagName === 'svg') {\n    root.metadata = header;\n  }\n\n  return {\n    type: 'root',\n    children: [root]\n  };\n}\n\nexport { parse };","map":{"version":3,"sources":["../node_modules/locate-character/dist/locate-character.es.js","../src/index.js"],"names":["const","let"],"mappings":"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","sourcesContent":["function getLocator(source, options) {\n    if (options === void 0) { options = {}; }\n    var offsetLine = options.offsetLine || 0;\n    var offsetColumn = options.offsetColumn || 0;\n    var originalLines = source.split('\\n');\n    var start = 0;\n    var lineRanges = originalLines.map(function (line, i) {\n        var end = start + line.length + 1;\n        var range = { start: start, end: end, line: i };\n        start = end;\n        return range;\n    });\n    var i = 0;\n    function rangeContains(range, index) {\n        return range.start <= index && index < range.end;\n    }\n    function getLocation(range, index) {\n        return { line: offsetLine + range.line, column: offsetColumn + index - range.start, character: index };\n    }\n    function locate(search, startIndex) {\n        if (typeof search === 'string') {\n            search = source.indexOf(search, startIndex || 0);\n        }\n        var range = lineRanges[i];\n        var d = search >= range.end ? 1 : -1;\n        while (range) {\n            if (rangeContains(range, search))\n                return getLocation(range, search);\n            i += d;\n            range = lineRanges[i];\n        }\n    }\n    ;\n    return locate;\n}\nfunction locate(source, search, options) {\n    if (typeof options === 'number') {\n        throw new Error('locate takes a { startIndex, offsetLine, offsetColumn } object as the third argument');\n    }\n    return getLocator(source, options)(search, options && options.startIndex);\n}\n\nexport { getLocator, locate };","import { locate } from 'locate-character';\n\nconst validNameCharacters = /[a-zA-Z0-9:_-]/;\nconst whitespace = /[\\s\\t\\r\\n]/;\nconst quotemark = /['\"]/;\n\nfunction repeat(str, i) {\n\tlet result = '';\n\twhile (i--) result += str;\n\treturn result;\n}\n\nexport function parse(source) {\n\tlet header = '';\n\tlet stack = [];\n\n\tlet state = metadata;\n\tlet currentElement = null;\n\tlet root = null;\n\n\tfunction error(message) {\n\t\tconst { line, column } = locate(source, i);\n\t\tconst before = source.slice(0, i);\n\t\tconst beforeLine = /(^|\\n).*$/.exec(before)[0].replace(/\\t/g, '  ');\n\t\tconst after = source.slice(i);\n\t\tconst afterLine = /.*(\\n|$)/.exec(after)[0];\n\n\t\tconst snippet = `${beforeLine}${afterLine}\\n${repeat(' ', beforeLine.length)}^`;\n\n\t\tthrow new Error(\n\t\t\t`${message} (${line}:${column}). If this is valid SVG, it's probably a bug in svg-parser. Please raise an issue at https://github.com/Rich-Harris/svg-parser/issues – thanks!\\n\\n${snippet}`\n\t\t);\n\t}\n\n\tfunction metadata() {\n\t\twhile ((i < source.length && source[i] !== '<') || !validNameCharacters.test(source[i + 1])) {\n\t\t\theader += source[i++];\n\t\t}\n\n\t\treturn neutral();\n\t}\n\n\tfunction neutral() {\n\t\tlet text = '';\n\t\twhile (i < source.length && source[i] !== '<') text += source[i++];\n\n\t\tif (/\\S/.test(text)) {\n\t\t\tcurrentElement.children.push({ type: 'text', value: text });\n\t\t}\n\n\t\tif (source[i] === '<') {\n\t\t\treturn tag;\n\t\t}\n\n\t\treturn neutral;\n\t}\n\n\tfunction tag() {\n\t\tconst char = source[i];\n\n\t\tif (char === '?') return neutral; // <?xml...\n\n\t\tif (char === '!') {\n\t\t\tif (source.slice(i + 1, i + 3) === '--') return comment;\n\t\t\tif (source.slice(i + 1, i + 8) === '[CDATA[') return cdata;\n\t\t\tif (/doctype/i.test(source.slice(i + 1, i + 8))) return neutral;\n\t\t}\n\n\t\tif (char === '/') return closingTag;\n\n\t\tconst tagName = getName();\n\n\t\tconst element = {\n\t\t\ttype: 'element',\n\t\t\ttagName,\n\t\t\tproperties: {},\n\t\t\tchildren: []\n\t\t};\n\n\t\tif (currentElement) {\n\t\t\tcurrentElement.children.push(element);\n\t\t} else {\n\t\t\troot = element;\n\t\t}\n\n\t\tlet attribute;\n\t\twhile (i < source.length && (attribute = getAttribute())) {\n\t\t\telement.properties[attribute.name] = attribute.value;\n\t\t}\n\n\t\tlet selfClosing = false;\n\n\t\tif (source[i] === '/') {\n\t\t\ti += 1;\n\t\t\tselfClosing = true;\n\t\t}\n\n\t\tif (source[i] !== '>') {\n\t\t\terror('Expected >');\n\t\t}\n\n\t\tif (!selfClosing) {\n\t\t\tcurrentElement = element;\n\t\t\tstack.push(element);\n\t\t}\n\n\t\treturn neutral;\n\t}\n\n\tfunction comment() {\n\t\tconst index = source.indexOf('-->', i);\n\t\tif (!~index) error('expected -->');\n\n\t\ti = index + 2;\n\t\treturn neutral;\n\t}\n\n\tfunction cdata() {\n\t\tconst index = source.indexOf(']]>', i);\n\t\tif (!~index) error('expected ]]>');\n\n\t\tcurrentElement.children.push(source.slice(i + 7, index));\n\n\t\ti = index + 2;\n\t\treturn neutral;\n\t}\n\n\tfunction closingTag() {\n\t\tconst tagName = getName();\n\n\t\tif (!tagName) error('Expected tag name');\n\n\t\tif (tagName !== currentElement.tagName) {\n\t\t\terror(`Expected closing tag </${tagName}> to match opening tag <${currentElement.tagName}>`);\n\t\t}\n\n\t\tallowSpaces();\n\n\t\tif (source[i] !== '>') {\n\t\t\terror('Expected >');\n\t\t}\n\n\t\tstack.pop();\n\t\tcurrentElement = stack[stack.length - 1];\n\n\t\treturn neutral;\n\t}\n\n\tfunction getName() {\n\t\tlet name = '';\n\t\twhile (i < source.length && validNameCharacters.test(source[i])) name += source[i++];\n\n\t\treturn name;\n\t}\n\n\tfunction getAttribute() {\n\t\tif (!whitespace.test(source[i])) return null;\n\t\tallowSpaces();\n\n\t\tconst name = getName();\n\t\tif (!name) return null;\n\n\t\tlet value = true;\n\n\t\tallowSpaces();\n\t\tif (source[i] === '=') {\n\t\t\ti += 1;\n\t\t\tallowSpaces();\n\n\t\t\tvalue = getAttributeValue();\n\t\t\tif (!isNaN(value) && value.trim() !== '') value = +value; // TODO whitelist numeric attributes?\n\t\t}\n\n\t\treturn { name, value };\n\t}\n\n\tfunction getAttributeValue() {\n\t\treturn quotemark.test(source[i]) ? getQuotedAttributeValue() : getUnquotedAttributeValue();\n\t}\n\n\tfunction getUnquotedAttributeValue() {\n\t\tlet value = '';\n\t\tdo {\n\t\t\tconst char = source[i];\n\t\t\tif (char === ' ' || char === '>' || char === '/') {\n\t\t\t\treturn value;\n\t\t\t}\n\n\t\t\tvalue += char;\n\t\t\ti += 1;\n\t\t} while (i < source.length);\n\n\t\treturn value;\n\t}\n\n\tfunction getQuotedAttributeValue() {\n\t\tconst quotemark = source[i++];\n\n\t\tlet value = '';\n\t\tlet escaped = false;\n\n\t\twhile (i < source.length) {\n\t\t\tconst char = source[i++];\n\t\t\tif (char === quotemark && !escaped) {\n\t\t\t\treturn value;\n\t\t\t}\n\n\t\t\tif (char === '\\\\' && !escaped) {\n\t\t\t\tescaped = true;\n\t\t\t}\n\n\t\t\tvalue += escaped ? `\\\\${char}` : char;\n\t\t\tescaped = false;\n\t\t}\n\t}\n\n\tfunction allowSpaces() {\n\t\twhile (i < source.length && whitespace.test(source[i])) i += 1;\n\t}\n\n\tlet i = metadata.length;\n\twhile (i < source.length) {\n\t\tif (!state) error('Unexpected character');\n\t\tstate = state();\n\t\ti += 1;\n\t}\n\n\tif (state !== neutral) {\n\t\terror('Unexpected end of input');\n\t}\n\n\tif (root.tagName === 'svg') root.metadata = header;\n\treturn {\n\t\ttype: 'root',\n\t\tchildren: [root]\n\t};\n}\n"]},"metadata":{},"sourceType":"module"}