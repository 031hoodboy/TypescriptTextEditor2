{"ast":null,"code":"import _ from 'lodash';\n\n// example AST helper, implementors to figure out non-imperative and immuatable implementation.\nvar visit = function visit(nodes, cb) {\n  nodes.forEach(function (node) {\n    cb(node);\n\n    if (node.children) {\n      visit(node.children, cb);\n    }\n  });\n};\n/**\n * Serializes the AST to a simple string\n */\n\n\nexport var serialize = function serialize(ast) {\n  var string = '';\n  visit(ast, function (node) {\n    var text = node.text || ''; // if BlockNode, append newline etc.\n\n    string += text;\n  });\n  return string;\n};\n/**\n * Serializes the AST to a HTML string\n */\n\nexport var serializeHtml = function serializeHtml(ast) {\n  // implement a custom HTML serializer by checking out example in: https://docs.slatejs.org/concepts/10-serializing#html0\n  // The following is just a placeholder example (not functional), you should loop over nodes and decide what to do.  Be mindful of carefully escaping and sanitizing HTML.\n  var html = '';\n  visit(ast, function (node) {\n    var text = node.text || '';\n    var tag = node.type;\n\n    if (tag) {\n      html += \"<\".concat(tag, \">\").concat(text, \"</\").concat(tag, \">\");\n    } else {\n      html += text;\n    }\n  });\n  return html;\n};\n/**\n * Extracts mentioned entities from the AST.\n */\n\nexport var extractMentions = function extractMentions(ast) {\n  var mentions = [];\n  visit(ast, function (node) {\n    if (node.type === 'mention') {\n      console.log(node);\n      mentions.push(node.entity);\n    }\n  });\n  return _.uniqWith(mentions, _.isEqual);\n};\n/**\n * Validates the AST.\n * Returns the AST if no errors found, throws otherwise.\n */\n\nexport var validate = function validate(ast) {\n  // Basic idea is to loop over nodes, make assertions on the interface of nodes to check for required attributes or warn against unsupported attributes.\n  // Validation can be implemented against the `ContentAst` interfaces (which support static validation but not runtime validation checks, which is what this method is aimed to provide)\n  return ast; // TODO\n};","map":{"version":3,"names":["_","visit","nodes","cb","forEach","node","children","serialize","ast","string","text","serializeHtml","html","tag","type","extractMentions","mentions","console","log","push","entity","uniqWith","isEqual","validate"],"sources":["/Users/hoodboy/Documents/htdocs/TypescriptTextEditor2/src/TextEditor/ast.ts"],"sourcesContent":["import _ from 'lodash';\n\nimport { AnyNode, ContentAst, Entity } from './types';\n\n// example AST helper, implementors to figure out non-imperative and immuatable implementation.\nconst visit = (nodes: AnyNode[], cb: (node: AnyNode) => void) => {\n  nodes.forEach((node) => {\n    cb(node);\n    if (node.children) {\n      visit(node.children, cb);\n    }\n  });\n};\n\n/**\n * Serializes the AST to a simple string\n */\nexport const serialize = (ast: ContentAst): string => {\n  let string = '';\n  visit(ast, (node) => {\n    const text = node.text || '';\n    // if BlockNode, append newline etc.\n    string += text;\n  });\n  return string;\n};\n\n/**\n * Serializes the AST to a HTML string\n */\nexport const serializeHtml = (ast: ContentAst): string => {\n  // implement a custom HTML serializer by checking out example in: https://docs.slatejs.org/concepts/10-serializing#html0\n  // The following is just a placeholder example (not functional), you should loop over nodes and decide what to do.  Be mindful of carefully escaping and sanitizing HTML.\n  let html = '';\n  visit(ast, (node) => {\n    const text = node.text || '';\n    const tag = node.type;\n    if (tag) {\n      html += `<${tag}>${text}</${tag}>`;\n    } else {\n      html += text;\n    }\n  });\n  return html;\n};\n\n/**\n * Extracts mentioned entities from the AST.\n */\nexport const extractMentions = (ast: ContentAst): Entity[] => {\n  const mentions: Entity[] = [];\n  visit(ast, (node) => {\n    if (node.type === 'mention') {\n      console.log(node);\n      mentions.push(node.entity);\n    }\n  });\n  return _.uniqWith(mentions, _.isEqual);\n};\n\n/**\n * Validates the AST.\n * Returns the AST if no errors found, throws otherwise.\n */\nexport const validate = (ast: ContentAst): ContentAst => {\n  // Basic idea is to loop over nodes, make assertions on the interface of nodes to check for required attributes or warn against unsupported attributes.\n  // Validation can be implemented against the `ContentAst` interfaces (which support static validation but not runtime validation checks, which is what this method is aimed to provide)\n  return ast; // TODO\n};\n"],"mappings":"AAAA,OAAOA,CAAP,MAAc,QAAd;;AAIA;AACA,IAAMC,KAAK,GAAG,SAARA,KAAQ,CAACC,KAAD,EAAmBC,EAAnB,EAAmD;EAC/DD,KAAK,CAACE,OAAN,CAAc,UAACC,IAAD,EAAU;IACtBF,EAAE,CAACE,IAAD,CAAF;;IACA,IAAIA,IAAI,CAACC,QAAT,EAAmB;MACjBL,KAAK,CAACI,IAAI,CAACC,QAAN,EAAgBH,EAAhB,CAAL;IACD;EACF,CALD;AAMD,CAPD;AASA;AACA;AACA;;;AACA,OAAO,IAAMI,SAAS,GAAG,SAAZA,SAAY,CAACC,GAAD,EAA6B;EACpD,IAAIC,MAAM,GAAG,EAAb;EACAR,KAAK,CAACO,GAAD,EAAM,UAACH,IAAD,EAAU;IACnB,IAAMK,IAAI,GAAGL,IAAI,CAACK,IAAL,IAAa,EAA1B,CADmB,CAEnB;;IACAD,MAAM,IAAIC,IAAV;EACD,CAJI,CAAL;EAKA,OAAOD,MAAP;AACD,CARM;AAUP;AACA;AACA;;AACA,OAAO,IAAME,aAAa,GAAG,SAAhBA,aAAgB,CAACH,GAAD,EAA6B;EACxD;EACA;EACA,IAAII,IAAI,GAAG,EAAX;EACAX,KAAK,CAACO,GAAD,EAAM,UAACH,IAAD,EAAU;IACnB,IAAMK,IAAI,GAAGL,IAAI,CAACK,IAAL,IAAa,EAA1B;IACA,IAAMG,GAAG,GAAGR,IAAI,CAACS,IAAjB;;IACA,IAAID,GAAJ,EAAS;MACPD,IAAI,eAAQC,GAAR,cAAeH,IAAf,eAAwBG,GAAxB,MAAJ;IACD,CAFD,MAEO;MACLD,IAAI,IAAIF,IAAR;IACD;EACF,CARI,CAAL;EASA,OAAOE,IAAP;AACD,CAdM;AAgBP;AACA;AACA;;AACA,OAAO,IAAMG,eAAe,GAAG,SAAlBA,eAAkB,CAACP,GAAD,EAA+B;EAC5D,IAAMQ,QAAkB,GAAG,EAA3B;EACAf,KAAK,CAACO,GAAD,EAAM,UAACH,IAAD,EAAU;IACnB,IAAIA,IAAI,CAACS,IAAL,KAAc,SAAlB,EAA6B;MAC3BG,OAAO,CAACC,GAAR,CAAYb,IAAZ;MACAW,QAAQ,CAACG,IAAT,CAAcd,IAAI,CAACe,MAAnB;IACD;EACF,CALI,CAAL;EAMA,OAAOpB,CAAC,CAACqB,QAAF,CAAWL,QAAX,EAAqBhB,CAAC,CAACsB,OAAvB,CAAP;AACD,CATM;AAWP;AACA;AACA;AACA;;AACA,OAAO,IAAMC,QAAQ,GAAG,SAAXA,QAAW,CAACf,GAAD,EAAiC;EACvD;EACA;EACA,OAAOA,GAAP,CAHuD,CAG3C;AACb,CAJM"},"metadata":{},"sourceType":"module"}